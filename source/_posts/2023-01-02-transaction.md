---
title: 事务
date: 2023-01-02 12:03:10
tags:
- 事务
---
## 事务消息
### rocketmq事务消息
RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，流程如下图所示：
![img.png](/images/transaction/img.png)
其具体工作流程分为正常事务消息的发送及提交和不正常情况下事务消息的补偿流程：
<!-- more -->
1. 在消息队列上开启一个事务主题。
2. 事务中第一个执行的服务发送一条“半消息”（半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的）给消息队列。
3. 半消息发送成功后，发送半消息的服务就会开始执行本地事务，根据本地事务执行结果来决定事务消息提交或者回滚。
4. 本地事务成功后会让这个“半消息”变成正常消息，供分布式事务后面的步骤执行自己的本地事务。（这里的事务消息，Producer不会因为Consumer消费失败而做回滚，采用事务消息的应用，
其**所追求的是高可用和最终一致性**，消息消费失败的话，RocketMQ自己会负责重推消息，直到消费成功。）

补偿流程：**RocketMQ提供事务反查来解决异常情况**，如果RocketMQ没有收到提交或者回滚的请求，Broker会定时到生产者上去反查本地事务的状态，
然后根据生产者本地事务的状态来处理这个“半消息”是提交还是回滚。值得注意的是我们需要根据自己的业务逻辑来实现反查逻辑接口，
然后根据返回值Broker决定是提交还是回滚。而且这个反查接口需要是无状态的，请求到任意一个生产者节点都会返回正确的数据

### kafka事务消息
#### 流处理
**要求每条消息都只处理一次，无一例外。**

如果流处理应用程序消费消息A并将结果作为消息B（B = f(A)），那么恰好一次处理保证意味着当且仅当B被成功生产后A才能被标记为消费
![img_1.png](/images/transaction/img_1.png)

**事务API使流处理应用程序能够在一个原子操作中使用、处理和生成消息**。这意味着，事务中的一批消息可以从许多主题分区接收、生成和确认。一个事务涉及的所有操作都作为整体成功或失败
#### kafka事务消息
与RocketMQ的事务消息用途不同，**Kafka的事务基本上是配合其幂等机制来实现Exactly-once（见上文）语义的。**

事务型Producer能够保证将消息原子性地写入到多个分区中。这批消息要么全部写入成功，要么全部失败。**以两阶段提交的方式**，实现消息的事务提交。


Kafka事务消息是由Producer、事务协调器、Broker、组协调器、Consumer等共同参与实现的。

### Pulsar的事务消息
Pulsar这里提供的事务区别于RocketMQ中2PC那种事务的实现方式，没有本地事务回查的机制，更类似于Kafka的事务实现机制。
Apache Pulsar中的事务主要用来保证类似Pulsar Functions这种流计算场景中**Exactly-once**语义的实现，这也符合Apache Pulsar本身Event Streaming的定位，即保证端到端（End-to-End）的事务实现的语义

在Pulsar中，对于事务语义是这样定义的：**允许事件流应用将消费、处理、生产消息整个过程定义为一个原子操作，即生产者或消费者能够处理跨多个主题和分区的消息，并确保这些消息作为一个单元被处理。**

Pulsar事务具有以下语义：

1. 事务中的所有操作都作为一个单元提交。要么提交所有消息，要么都不提交。

2. 每条消息只写入或处理一次，不会丢失数据或重复（即使发生故障）。

3. 如果事务中止，则此事务中的所有写入和确认都将回滚。

## 总结
RocketMQ和Kafka/Pulsar的事务消息实用的场景是不一样的。

**RocketMQ中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。**并且RocketMQ增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。

**Kafka中的事务，它解决的问题是，确保在一个事务中发送的多条消息，要么都成功，要么都失败。**（**这里面的多条消息不一定要在同一个主题和分区中，可以是发往多个主题和分区的消息**）当然也可以在kafka事务执行过程中开启本地事务来实现类似RocketMQ事务消息的效果，但是Kafka是没有事务消息反查机制的，它是直接抛出异常的，用户可以根据异常来实现自己的重试等方法保证事务正常运行。

它们的共同点就是：**都是通过两阶段提交来实现事务的**，事务消息都保存在单独的主题上。不同的地方就是RocketMQ是通过“半消息”来实现的，kafka是直接将消息发送给对应的topic，通过客户端来过滤实现的。而且它们两个使用的场景区别是非常之大的，RockteMQ主要解决的是基于本地事务和消息的数据一致性，而**Kafka的事务则是用于实现它的Exactly-once机制，应用于实时流计算的场景中。**

Pulsar的事务消息和Kafka应用场景和语义类似，只是由于底层实现机制有差别，在一些细节上有区别。

相信看到这里就非常清楚了，对于事务消息如何选型和应用，首先要明白你的业务需求是什么。是要实现分布式事务的最终一致性，还是要实现Exactly-once （精确一次）语义？明白之后需求，选择什么组件就十分明确了。

## 参考
https://mp.weixin.qq.com/s/Cmw3QExqCfBAz9V0AlsS9A