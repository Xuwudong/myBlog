---
title: meeting
date: 2023-01-05 15:59:41
tags:
hidden: true
---
ddd
10亿数求前100
业务安全
设计调度系统

## 1.7
### 面试题
1. [redis如何解决分布式锁的可靠性？](https://www.cnblogs.com/xiaolincoding/p/16517673.html)
* 解锁需要判断删除的value是不是当前加锁的value，用lua脚本保证原子性
* 缺点：
  * 超时时间不好控制
    * 守护进程续约超时时间
  * Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性
* red-lock
  * 让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。
  * 加锁成功需要满足两个条件
    * 条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；
    * 条件二：客户端获取锁的总耗时（t1）没有超过锁的有效时间。

2. [AQS原理](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)
* 等待队列头部是个虚拟节点
* 非公平锁 tryAcquire()会直接尝试获取锁，公平锁 tryAcquire会先判断等待队列是否为空，为空才尝试获取锁
* 
  同步工具	同步工具与AQS的关联
  * ReentrantLock	使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。
  * Semaphore	使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。
  * CountDownLatch	使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。
  * ReentrantReadWriteLock	使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。
  * ThreadPoolExecutor	Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。

## 1.8
### 面试题
1. [ddd](https://www.9932xt.cn/2022/12/09/ddd/?highlight=ddd)
2. [线程池](https://juejin.cn/post/6946087172143317023) 

### 算法题
1. 最长回文子串
   1. 动态规划解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    a := make([][]bool, len(s))
    for i := range a {
		a[i] = make([]bool, len(s))
	}
    for i := 0;i< len(s);i++ {
        a[i][i] = true
    }
    start := 0
    max := 1
    // L从小变大
    for L := 1; L <= len(s);L++  {
        for i := 0;i <len(s);i++ {
            j := i + L 
            if j >= len(s) {
                break 
            }
                if s[i] == s[j] {
                    if j - i < 3 {
                        a[i][j] = true
                    } else {
                        a[i][j] = a[i + 1][j-1]
                    }
                } else {
                    a[i][j] = false
                }
                if a[i][j] && j - i + 1 >max {
                    max = j - i +1
                    start  = i
                }
        }
            
    }
    
    return s[start:start+max]
    
}
```
  2. 中心扩散解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start := 0
    end := 0
    for i := 0;i < len(s);i++ {
        l, r := expand(s, i, i)
        if r - l > end - start {
            start = l
            end = r
        }
        l, r = expand(s, i, i +1)
        if r - l > end - start {
            start = l
            end = r
        }
    }
    return s[start:end + 1]
    
}

func expand(s string, l int, r int) (int, int) {
    for ;l >=0 && r < len(s) && s[l] == s[r]; {
        l--
        r++
    } 
     l++
     r--
     return l, r
}
```


