---
title: meeting
date: 2023-01-05 15:59:41
tags:
hidden: true
---
ddd
10亿数求前100
业务安全
设计调度系统

## 1.7
### 面试题
1. [redis如何解决分布式锁的可靠性？](https://www.cnblogs.com/xiaolincoding/p/16517673.html)
* 解锁需要判断删除的value是不是当前加锁的value，用lua脚本保证原子性
* 缺点：
  * 超时时间不好控制
    * 守护进程续约超时时间
  * Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性
* red-lock
  * 让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。
  * 加锁成功需要满足两个条件
    * 条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；
    * 条件二：客户端获取锁的总耗时（t1）没有超过锁的有效时间。

2. [AQS原理](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)
* 等待队列头部是个虚拟节点
* 非公平锁 tryAcquire()会直接尝试获取锁，公平锁 tryAcquire会先判断等待队列是否为空，为空才尝试获取锁
* 
  同步工具	同步工具与AQS的关联
  * ReentrantLock	使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。
  * Semaphore	使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。
  * CountDownLatch	使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。
  * ReentrantReadWriteLock	使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。
  * ThreadPoolExecutor	Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。

## 1.8
### 面试题
1. [ddd](https://www.9932xt.cn/2022/12/09/ddd/?highlight=ddd)
2. [线程池](https://juejin.cn/post/6946087172143317023) 

### 算法题
1. 最长回文子串
   1. 动态规划解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    a := make([][]bool, len(s))
    for i := range a {
		a[i] = make([]bool, len(s))
	}
    for i := 0;i< len(s);i++ {
        a[i][i] = true
    }
    start := 0
    max := 1
    // L从小变大
    for L := 1; L <= len(s);L++  {
        for i := 0;i <len(s);i++ {
            j := i + L 
            if j >= len(s) {
                break 
            }
                if s[i] == s[j] {
                    if j - i < 3 {
                        a[i][j] = true
                    } else {
                        a[i][j] = a[i + 1][j-1]
                    }
                } else {
                    a[i][j] = false
                }
                if a[i][j] && j - i + 1 >max {
                    max = j - i +1
                    start  = i
                }
        }
            
    }
    
    return s[start:start+max]
    
}
```
  2. 中心扩散解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start := 0
    end := 0
    for i := 0;i < len(s);i++ {
        l, r := expand(s, i, i)
        if r - l > end - start {
            start = l
            end = r
        }
        l, r = expand(s, i, i +1)
        if r - l > end - start {
            start = l
            end = r
        }
    }
    return s[start:end + 1]
    
}

func expand(s string, l int, r int) (int, int) {
    for ;l >=0 && r < len(s) && s[l] == s[r]; {
        l--
        r++
    } 
     l++
     r--
     return l, r
}
```

## 1.20
1. 操作系统内存管理

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。

内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。

于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了页表太大占用内存空间的问题，**页表一定要覆盖全部虚拟地址空间，对于32位系统，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。**

但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。

- 项目
  - 多益
    - top10 堆
    - 秒杀 Redis队列将请求排队 先进先出 缺点（占内存），计数统计

  - BIGO
    - 分布式ID 雪花算法 优缺点
      - 机器号 使用REDIS INCR获取机器号 ；大于等于上限99时加分布式锁删除机器号的key以限制机器号
      - mod(业务ID) 将统一用户ID的订单分片到同一个分片库中
      - 缺点 存在时钟偏移的问题 解决办法：记录上次生成ID的时间，自旋等待当前时间大于上次生成ID的时间
    - 分布式锁 Redis zookeeper实现优缺点
    - Saga（DOService DOSuccess DOFail）TCC（conform或者Fail重试后仍失败则记录日志进行回滚） 2PC 3PC raft 
    - 定时对账 线下补偿
    - Redis缓存
    - 分库分表
    - xxljob 搭建与迁移定时任务

  - 字节
    - 教育
      - CMS平台 DDD 示例 TODO
      - 公告 
        - ES使用 写流程，读流程 近实时，通过refresh（）达到完全实时
        - 压测tps上不去， 报invalid connection异常 update语句没有加索引导致，服务端超时时间内拿不到锁报的异常
      - 日历 读、写扩散，新日程数据推拉模型
      - erds client开发
      - 协同管理工作
        - 统一将云平台接口迁移到开平
    - 物流 
      - api 迁移正确性保证 bcp对比
      - 超时治理 
        - 内部治理（优化代码+调整超时时间+幂等接口自动重试）
        - 外部治理 控制重试策略（避免流量放大）


- 限流
- 判断图是否有环
- 容器技术原理
- zookeeper
- 异地多活 http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/
- TCC异常情况
- MySQL主从切换
- 朋友圈设计



- HR面试
  - 离职原因
    - 字节工作太忙了，每天的节奏都很快，创业时和在国际电商都是10点下班
    - 工作业绩没有得到应有的认可
    - 团队氛围不是很好
  - 选择酷狗的原因
    - 酷狗工作节奏相对来说没有那么快
    - 业务比较稳定，能够持续发展
    - 有朋友在酷狗，反馈公司不错，也拿了S级员工
  - 未来2-3年职业规划
    - 增强工作业务能力，工作中积累处理各种复杂业务的技术方案相关经验，定期输出技术文章在团队内分享，和业务团队一起共同成长
    - 业余时间学习k8s、分布式存储具体实现细节(比如etcd)等技术栈，多逛开源论坛，并尝试提交mr,争取为开源项目做出一定的贡献,进一步增强技术能力
    - 增强项目规划，项目进度把控能力；增强沟通表达能力，争取能够在贵公司更上一层楼
  - 期望薪酬
    - 先问对方大概能给到多少 
    - 期望在目前薪资的基础上，增加10%左右，也是对自己在字节过去一两年里努力工作成长的一个认可
  - 觉得部门整体哪些做得好，哪些做的不好
    - 丰富的SOP文档；
    - 技术评审会拉上组内同学，大家各抒己见，避免个人思维局限留下问题。
    - 每两周一次的技术分享，增强技术能力与视野；
    - 分工明确，边界清晰；上线工作流校验功能完善，能够最大可能避免bug;
    - 有时需求沟通没有做好，没有一个统一的群去同步信息；api文档由产品维护的不好。
  - 目前做的比较有成就感的工作
    - 独自负责分拣子系统的开发与运维工作，独自把控项目进度，解决需求技术难题，保持与产品，前端，测试同学的良好沟通与合作。
  - 怎么处理矛盾
    - 换位思考，想下别人的困境和期望是什么；如果有信息不对等或者其他原因造成的误会，就尽力消除误会；如果是对方自己原因就帮对方想下对策
    - 力求双赢，无法保证双赢就冷静下来好好讲逻辑，一般这里能解决问题，如果逻辑讲不通，自上而下推动