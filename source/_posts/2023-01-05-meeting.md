---
title: meeting
date: 2023-01-05 15:59:41
tags:
hidden: true
---
ddd
10亿数求前100
业务安全
设计调度系统

## 1.7
### 面试题
1. [redis如何解决分布式锁的可靠性？](https://www.cnblogs.com/xiaolincoding/p/16517673.html)
* 解锁需要判断删除的value是不是当前加锁的value，用lua脚本保证原子性
* 缺点：
  * 超时时间不好控制
    * 守护进程续约超时时间
  * Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性
* red-lock
  * 让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。
  * 加锁成功需要满足两个条件
    * 条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；
    * 条件二：客户端获取锁的总耗时（t1）没有超过锁的有效时间。

2. [AQS原理](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)
* 等待队列头部是个虚拟节点
* 非公平锁 tryAcquire()会直接尝试获取锁，公平锁 tryAcquire会先判断等待队列是否为空，为空才尝试获取锁
* 
  同步工具	同步工具与AQS的关联
  * ReentrantLock	使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。
  * Semaphore	使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。
  * CountDownLatch	使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。
  * ReentrantReadWriteLock	使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。
  * ThreadPoolExecutor	Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。

## 1.8
### 面试题
1. [ddd](https://www.9932xt.cn/2022/12/09/ddd/?highlight=ddd)
2. [线程池](https://juejin.cn/post/6946087172143317023) 

### 算法题
1. 最长回文子串
   1. 动态规划解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    a := make([][]bool, len(s))
    for i := range a {
		a[i] = make([]bool, len(s))
	}
    for i := 0;i< len(s);i++ {
        a[i][i] = true
    }
    start := 0
    max := 1
    // L从小变大
    for L := 1; L <= len(s);L++  {
        for i := 0;i <len(s);i++ {
            j := i + L 
            if j >= len(s) {
                break 
            }
                if s[i] == s[j] {
                    if j - i < 3 {
                        a[i][j] = true
                    } else {
                        a[i][j] = a[i + 1][j-1]
                    }
                } else {
                    a[i][j] = false
                }
                if a[i][j] && j - i + 1 >max {
                    max = j - i +1
                    start  = i
                }
        }
            
    }
    
    return s[start:start+max]
    
}
```
  2. 中心扩散解题
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start := 0
    end := 0
    for i := 0;i < len(s);i++ {
        l, r := expand(s, i, i)
        if r - l > end - start {
            start = l
            end = r
        }
        l, r = expand(s, i, i +1)
        if r - l > end - start {
            start = l
            end = r
        }
    }
    return s[start:end + 1]
    
}

func expand(s string, l int, r int) (int, int) {
    for ;l >=0 && r < len(s) && s[l] == s[r]; {
        l--
        r++
    } 
     l++
     r--
     return l, r
}
```

## 1.20
1. 操作系统内存管理

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套的虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。

内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。

于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了页表太大占用内存空间的问题，**页表一定要覆盖全部虚拟地址空间，对于32位系统，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。**

但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

另外，Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。