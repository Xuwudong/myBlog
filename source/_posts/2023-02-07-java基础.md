---
title: java基础
date: 2023-02-07 13:02:59
tags:
---
Java 不提供指针来直接访问内存，程序内存更加安全。可以使用线性分配器分配内存（**因为线性分配器需要与具有拷贝特性的垃圾回收算法配合**，所以 C 和 C++ ，
go等需要直接对外暴露指针的语言就无法使用该策略）


包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。 为什么说是几乎所有对象实例呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，
会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

volatile 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是**禁用 CPU 缓存**。如果我们将一个变量使用 volatile 修饰，
这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是**防止 JVM 的指令重排序**

[threadloal内存泄漏问题](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%BC%E8%87%B4%E7%9A%84)



主内存 ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)
本地内存 ：每个线程都有一个私有的本地内存（比如机器的寄存器）来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。



JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。
更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，**无论这两个操作是否在同一个线程里**。

happens-before 常见规则有哪些？
谈谈你的理解？happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。
程序顺序规则 ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
解锁规则 ：解锁 happens-before 于加锁；
volatile 变量规则 ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
传递规则 ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
线程启动规则 ：Thread 对象的 start()方法 happens-before 于此线程的每一个动作。

动态链接 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。
当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。

从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，
然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。


大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。


* 部分收集 (Partial GC)：
    * 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
    * 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
    * 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
* 整堆收集 (Full GC)：收集整个 Java 堆和方法区。#
  
**空间分配担保**是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

* 哪些对象可以作为 GC Roots 呢？
    * 虚拟机栈(栈帧中的本地变量表)中引用的对象
    * 本地方法栈(Native 方法)中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 所有被同步锁持有的对象


软引用 如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**软引用可用来实现内存敏感的高速缓存**。
弱引用 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

* 如何判断一个类是无用的类
    * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    * 加载该类的 ClassLoader 已经被回收。
    * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”(让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。)算法进行垃圾收集。


* CMS收集器缺点
    * **对 CPU 资源敏感**；
      由于GC线程是CPU密集型线程，且它与用户线程在“并发标记”与“并发清除”阶段是并发执行的，所以GC线程会与用户线程竞争CPU资源，使得部分用户线程得不到执行，导致应用程序的总吞吐量降低。
    * **无法处理浮动垃圾**； 无法处理并发标记阶段 本来可达的对象由于用户线程的并发运行变成不可达的这部分对象
    * 它使用的回收算法-“标记-清除”**算法会导致收集结束时会有大量空间碎片产生**。

* G1收集器特点
  * 并行与并发
  * 分代收集
  * 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。、
  * **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

* 加载
类加载过程的第一步，主要完成下面 3 件事情：
  * 通过全类名获取定义此类的二进制字节流
  * 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
  * 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口

* 连接
  *   验证
    ![img.png](/images/java基础/img.png)
  *  准备
    * 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段
  * 解析
    * 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。
  * 初始化 只有主动去使用类才会初始化类
    * 初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。
