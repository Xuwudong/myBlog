---
title: mysql
date: 2022-11-17 15:20:21
tags:
- MySQL
- 中间件
- DB
categories:
- MySQL
---
* 是否分片不是取决于数据量千万条。而是取决于主节点写入速度是不是太高导致主从延迟太大，
或者主节点机器空间不够了，我司最大2.8T
### 主从同步

* 主从复制方式 
* 一致性保证

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 
而当前读，总是读取已经提交完成的最新版本。
* 间隙锁主要用来解决幻读的问题，在读已提交的隔离级别下，并且是“当前读”，才会产生幻读。
  InnoDB在可重复读的事务隔离级别下，会有间隙锁；也就是说，在可重复读级别下，是不会出现幻读现象的。
  间隙锁之间不存在冲突关系。与间隙锁冲突的是“往这个间隙插入一个记录”的操作。 

* dml语句查询时需要获取表的MDL锁，ddl语句执行时也要获取表的MDL锁。后面的dml语句需要等待前面的ddl语句执行完才能继续执行，因此在业务高峰
  期操作ddl,可能导致连接暴涨，解决办法之一是ddl语句加上超时和重试
```sql
    ALTER TABLE tbl_name WAIT N add column ...
```

* binlog存储格式Statement只会记录SQL语句，但是并不能保证所有情况下这些语句在从库上能够正确的被重放出来。因为可能顺序不对。
* MySQL什么时候会记录binlog呢？是在事务提交的时候，并不是按照语句的执行顺序来记录，当记录完binlog之后 ，
  就会通知底层的存储引擎提交事务，所以有可能因为语句顺序错误导致语句出错。
### undo log


### redo log 

    

### 索引
* 联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，
但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配

* 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，
直接过滤掉不满足条件的记录，减少回表次数。
* type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：

  * All（全表扫描）；
  * index（全索引扫描）；
  * range（索引范围扫描）；
  * ref（非唯一索引扫描）；
  * eq_ref（唯一索引扫描）；
  * const（结果只有一条的主键或唯一索引扫描）。
  
const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。

* InnoDB 的数据是按「**数据页**」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过**双向链表**的形式组织起来，物理上不连续，但是逻辑上连续。
b
* 数据页内包含用户记录，每个记录之间用**单向链表**的方式组织起来，为了加快在数据页内高效查询记录，设计了一个**页目录，页目录存储各个槽（分组)**，且主键值是有序的，于是可以通过**二分查找法**的方式进行检索从而提高效率。

* 为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，**每个节点都是一个数据页**。

* MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

  * B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，**查询底层节点的磁盘 I/O次数会更少**。
  * B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树**在插入、删除的效率都更高**，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
  * B+ 树叶子节点之间**用链表连接了起来，有利于范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
* 如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。
