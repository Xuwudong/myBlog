---
title: mysql
date: 2022-11-17 15:20:21
tags:
- MySQL
- 中间件
- DB
categories:
- MySQL
---
* 是否分片不是取决于数据量千万条。而是取决于主节点写入速度是不是太高导致主从延迟太大，
或者主节点机器空间不够了，我司最大2.8T
## 主从同步

* 主从复制方式 
* 一致性保证

* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于读提交，查询只承认在语句启动前就已经提交完成的数据； 
而当前读，总是读取已经提交完成的最新版本。
* 间隙锁主要用来解决幻读的问题，在读已提交的隔离级别下，并且是“当前读”，才会产生幻读。
  InnoDB在可重复读的事务隔离级别下，会有间隙锁；也就是说，在可重复读级别下，是不会出现幻读现象的。
  间隙锁之间不存在冲突关系。与间隙锁冲突的是“往这个间隙插入一个记录”的操作。 

* dml语句查询时需要获取表的MDL锁，ddl语句执行时也要获取表的MDL锁。后面的dml语句需要等待前面的ddl语句执行完才能继续执行，因此在业务高峰
  期操作ddl,可能导致连接暴涨，解决办法之一是ddl语句加上超时和重试
```sql
    ALTER TABLE tbl_name WAIT N add column ...
```

* binlog存储格式Statement只会记录SQL语句，但是并不能保证所有情况下这些语句在从库上能够正确的被重放出来。因为可能顺序不对。
* MySQL什么时候会记录binlog呢？是在事务提交的时候，并不是按照语句的执行顺序来记录，当记录完binlog之后 ，
  就会通知底层的存储引擎提交事务，所以有可能因为语句顺序错误导致语句出错。
### undo log


### redo log 

    

### 索引
* 联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，
但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配

* 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，
直接过滤掉不满足条件的记录，减少回表次数。
* type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：

  * All（全表扫描）；
  * index（全索引扫描）；
  * range（索引范围扫描）；
  * ref（非唯一索引扫描）；
  * eq_ref（唯一索引扫描）；
  * const（结果只有一条的主键或唯一索引扫描）。
  
const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。

* InnoDB 的数据是按「**数据页**」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过**双向链表**的形式组织起来，物理上不连续，但是逻辑上连续。
b
* 数据页内包含用户记录，每个记录之间用**单向链表**的方式组织起来，为了加快在数据页内高效查询记录，设计了一个**页目录，页目录存储各个槽（分组)**，且主键值是有序的，于是可以通过**二分查找法**的方式进行检索从而提高效率。

* 为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，**每个节点都是一个数据页**。

* MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

  * B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，**查询底层节点的磁盘 I/O次数会更少**。
  * B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树**在插入、删除的效率都更高**，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
  * B+ 树叶子节点之间**用链表连接了起来，有利于范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
* 如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。


### online ddl
我给你简单描述一下引入了 Online DDL 之后，重建表的流程：
1. 建立一个临时文件，扫描表 A 主键的所有数据页；
2. 用数据页中表 A 的记录生成 B+ 树， 存储到临时文件中；
3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
4. 临时文件生成后， 将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
5. 用临时文件替换表 A 的数据文件。
![img.png](/images/mysql/img.png)
本质上是 Copy-On-Write 的思想，Redis 的 Replication 中也会用到

// 主备切换

### 基于位点的主备切换
当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：
```azure
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
MASTER_LOG_FILE=$master_log_name 
MASTER_LOG_POS=$master_log_pos
```
最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。
问题：相同的日志，主库A 的位点和 备库A’的位点是不同的。
考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务。

一种取同步位点的方法是这样的：
1. 等待新主库 A’把中转日志（relay log）全部同步完成；
2. 在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；
3. 取原主库 A 故障的时刻 T；
4. 用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。

5. 缺点：需要主动判断错误跳过已经执行的事务

### GTID
GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。

### 基于 GTID 的主备切换
在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：
```
CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
master_auto_position=1
```
 其中，master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。可以看到，前面让我们头疼不已的 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，已经不需要指定了。
 我们把现在这个时刻，实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。接下来，我们就看看现在的主备切换逻辑。
我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：
1. 实例 B 指定主库 A’，基于主备协议建立连接。
2. 实例 B 把 set_b 发给主库 A’。
3. 实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。
   1. 如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；
   2. 如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；
4. 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。

业务高峰期时，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。

## 读写分离

### 处理主从不一致的方案
* 强制走主库方案；
* sleep 方案；
* 判断主备无延迟方案；
* 配合 semi-sync 方案；
* 等主库位点方案；
* 等 GTID 方案。

### 判断主备无延迟方案
* 第一种确保主备无延迟的方法是，每次从库执行查询请求前，**先判断 seconds_behind_master 是否已经等于 0**。如果还不等于 0 ，
那就必须等到这个参数变为 0 才能执行查询请求。缺点：单位是秒，不够精确
* 第二种方法，对比主从位点确保主备无延迟
* 第三种方法，对比主从 GTID 集合确保主备无延迟
缺点：上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。

### 配合 semi-sync 方案
semi-sync 做了这样的设计：
1. 事务提交的时候，主库把 binlog 发给从库；
2. 从库收到 binlog 以后，发回给主库一个 ack，表示收到了；
3. 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。
可以避免主库挂了，binlog没有同步到从库的数据丢失情况
缺点：
* 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；
* 在持续延迟的情况下，可能出现过度等待的问题。

### 等主库位点方案
```azure
select master_pos_wait(file, pos[, timeout]);
```
这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。
查询逻辑：
1. trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；
2. 选定一个从库执行查询语句；
3. 在从库上执行 select master_pos_wait(File, Position, 1)；
4. 如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句。（做好限流）

缺点：需要主动查询主库位点

### 等 GTID 方案
```azure
 select wait_for_executed_gtid_set(gtid_set, 1);
```
这条命令的逻辑是：等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；超时返回 1。

这时，等 GTID 的执行流程就变成了：
1. trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
2. 选定一个从库执行查询语句；
3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；
4. 如果返回值是 0，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句。


## 高可用

MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave(取second_behind_master的最小的master)提升为新的master，
然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。
