---
title: go栈内存管理
date: 2022-12-30 12:38:41
tags: 
- 栈
categories:
  - go
  - 内存
---
## 设计原理

栈区的内存一般由编译器自动分配和释放，**其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在**，
这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。
<!-- more -->
### 寄存器
1. Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址
![img.png](/images/go_stack_management/img.png)
2. 当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。
### 线程栈
1. 多数架构上默认栈大小都在 2 ~ 4 MB 左右，极少数架构会使用 32 MB 的栈，用户程序可以在分配的栈上存储函数参数和局部变量。
2. 线程和进程都是代码执行的上下文，但是如果一个应用程序包含成百上千个执行上下文并且每个上下文都是线程，会占用大量的内存空间并带来其他的额外开销，
Go 语言在设计时认为执行上下文是轻量级的，所以它在用户态实现 Goroutine 作为执行上下文。
### 逃逸分析
手动分配内存会导致如下的两个问题：

1. 不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；
2. 需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；
   在编译器优化中，**逃逸分析是用来决定指针动态作用域的方法**。
* Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 new、make 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：
1. 指向栈对象的指针不能存在于堆中；
2. 指向栈对象的指针不能在栈对象回收后存活；
![img_1.png](/images/go_stack_management/img_1.png)

### 栈内存空间
Goroutine 的初始栈大小为 2KB
#### 分段栈
 ![img_2.png](/images/go_stack_management/img_2.png)

分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：

1. 如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，**这被称为热分裂问题**（Hot split）；
2. 一旦 Goroutine **使用的内存越过了分段栈的扩缩容阈值**，运行时会触发栈的扩容和缩容，带来额外的工作量；

#### 连续栈
连续栈可以解决分段栈中存在的两个问题，其核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，
新的局部变量或者函数调用就有充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：

1. 在内存空间中分配更大的栈内存空间；
2. 将旧栈中的所有内容复制到新栈中；
3. **将指向旧栈对应变量的指针重新指向新栈**；
4. 销毁并回收旧栈的内存空间；
![img_3.png](/images/go_stack_management/img_3.png)
因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题10，在 GC 期间如果 Goroutine 使用了栈内存的四分之一，
那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。



## 参考
[go-栈内存管理](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E7%BA%BF%E7%A8%8B%E6%A0%88)